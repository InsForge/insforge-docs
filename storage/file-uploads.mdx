---
title: File Uploads
description: Upload files with automatic naming, validation, and progress tracking
---

# File Uploads

Upload files to InsForge storage with automatic unique naming or custom keys.

## Upload Methods

### Auto-Generated Filename (Recommended)

Prevents overwrites with unique names:

```bash
curl -X POST http://localhost:7130/api/storage/buckets/uploads/objects \
  -H "Authorization: Bearer TOKEN" \
  -F "file=@document.pdf"

# Response
{
  "key": "document-1704067200-xyz789.pdf",
  "bucket": "uploads",
  "size": 204800,
  "mimeType": "application/pdf",
  "uploadedAt": "2024-01-01T00:00:00Z",
  "url": "/api/storage/buckets/uploads/objects/document-1704067200-xyz789.pdf"
}
```

### Custom Filename

<Warning>
Using custom filenames with PUT will fail if file already exists.
</Warning>

```bash
curl -X PUT http://localhost:7130/api/storage/buckets/uploads/objects/my-file.pdf \
  -H "Authorization: Bearer TOKEN" \
  -F "file=@document.pdf"
```

## File Size Limits

```bash
# Default limits
MAX_FILE_SIZE=10485760      # 10MB per file
MAX_FILES_PER_FIELD=10      # 10 files per request
REQUEST_BODY_LIMIT=104857600 # 100MB total
```

## JavaScript Upload

### Single File Upload

```javascript
async function uploadFile(file, bucket = 'uploads') {
  // Validate before upload
  if (file.size > 10 * 1024 * 1024) {
    throw new Error('File too large (max 10MB)');
  }
  
  const formData = new FormData();
  formData.append('file', file);
  
  const token = localStorage.getItem('access_token');
  const response = await fetch(
    `http://localhost:7130/api/storage/buckets/${bucket}/objects`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: formData
    }
  );
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || 'Upload failed');
  }
  
  return response.json();
}

// Usage
const fileInput = document.querySelector('input[type="file"]');
const result = await uploadFile(fileInput.files[0]);
console.log('Uploaded:', result.url);
```

### Multiple Files

```javascript
async function uploadMultipleFiles(files, bucket = 'uploads') {
  const uploads = [];
  
  for (const file of files) {
    try {
      const result = await uploadFile(file, bucket);
      uploads.push({ success: true, ...result });
    } catch (error) {
      uploads.push({ 
        success: false, 
        fileName: file.name, 
        error: error.message 
      });
    }
  }
  
  return uploads;
}

// Usage
const files = Array.from(fileInput.files);
const results = await uploadMultipleFiles(files);

const successful = results.filter(r => r.success);
const failed = results.filter(r => !r.success);

console.log(`Uploaded ${successful.length}/${files.length} files`);
```

## Upload with Progress

```javascript
function uploadWithProgress(file, onProgress) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append('file', file);
    
    // Progress tracking
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        onProgress(percentComplete);
      }
    });
    
    // Completion
    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error('Upload failed'));
      }
    });
    
    // Error
    xhr.addEventListener('error', () => {
      reject(new Error('Network error'));
    });
    
    // Setup request
    const token = localStorage.getItem('access_token');
    xhr.open('POST', 'http://localhost:7130/api/storage/buckets/uploads/objects');
    xhr.setRequestHeader('Authorization', `Bearer ${token}`);
    
    // Send
    xhr.send(formData);
  });
}

// Usage
await uploadWithProgress(file, (percent) => {
  console.log(`Upload progress: ${percent.toFixed(0)}%`);
  progressBar.style.width = `${percent}%`;
});
```

## React Upload Component

```jsx
function FileUploader() {
  const [files, setFiles] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState({});
  
  async function handleDrop(e) {
    e.preventDefault();
    const droppedFiles = Array.from(e.dataTransfer.files);
    await uploadFiles(droppedFiles);
  }
  
  async function handleSelect(e) {
    const selectedFiles = Array.from(e.target.files);
    await uploadFiles(selectedFiles);
  }
  
  async function uploadFiles(fileList) {
    setUploading(true);
    
    for (const file of fileList) {
      try {
        // Validate
        if (file.size > 10 * 1024 * 1024) {
          alert(`${file.name} is too large (max 10MB)`);
          continue;
        }
        
        // Upload with progress
        await uploadWithProgress(
          file,
          (percent) => {
            setProgress(prev => ({
              ...prev,
              [file.name]: percent
            }));
          }
        ).then(result => {
          setFiles(prev => [...prev, {
            name: file.name,
            url: `http://localhost:7130${result.url}`,
            size: result.size,
            key: result.key
          }]);
        });
        
      } catch (error) {
        console.error(`Failed to upload ${file.name}:`, error);
      }
    }
    
    setUploading(false);
    setProgress({});
  }
  
  return (
    <div 
      onDrop={handleDrop}
      onDragOver={(e) => e.preventDefault()}
      style={{
        border: '2px dashed #ccc',
        padding: '20px',
        textAlign: 'center'
      }}
    >
      <p>Drag and drop files here or</p>
      <input 
        type="file" 
        multiple 
        onChange={handleSelect}
        disabled={uploading}
      />
      
      {uploading && (
        <div>
          {Object.entries(progress).map(([name, percent]) => (
            <div key={name}>
              <span>{name}</span>
              <progress value={percent} max="100" />
              <span>{percent.toFixed(0)}%</span>
            </div>
          ))}
        </div>
      )}
      
      <div>
        <h3>Uploaded Files</h3>
        {files.map(file => (
          <div key={file.key}>
            <a href={file.url} target="_blank">{file.name}</a>
            <span> ({(file.size / 1024).toFixed(1)} KB)</span>
            <button onClick={() => deleteFile(file.key)}>Delete</button>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## File Type Validation

```javascript
const ALLOWED_TYPES = {
  images: {
    mimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    extensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
    maxSize: 5 * 1024 * 1024 // 5MB
  },
  documents: {
    mimeTypes: ['application/pdf', 'application/msword', 'text/plain'],
    extensions: ['.pdf', '.doc', '.docx', '.txt'],
    maxSize: 10 * 1024 * 1024 // 10MB
  },
  videos: {
    mimeTypes: ['video/mp4', 'video/webm'],
    extensions: ['.mp4', '.webm'],
    maxSize: 100 * 1024 * 1024 // 100MB
  }
};

function validateFile(file, category = 'images') {
  const rules = ALLOWED_TYPES[category];
  
  // Check MIME type
  if (!rules.mimeTypes.includes(file.type)) {
    throw new Error(`Invalid file type. Allowed: ${rules.extensions.join(', ')}`);
  }
  
  // Check size
  if (file.size > rules.maxSize) {
    const maxMB = rules.maxSize / 1024 / 1024;
    throw new Error(`File too large. Max size: ${maxMB}MB`);
  }
  
  // Check extension
  const ext = '.' + file.name.split('.').pop().toLowerCase();
  if (!rules.extensions.includes(ext)) {
    throw new Error(`Invalid extension. Allowed: ${rules.extensions.join(', ')}`);
  }
  
  return true;
}
```

## Image Upload with Preview

```jsx
function ImageUpload() {
  const [preview, setPreview] = useState(null);
  const [uploadedUrl, setUploadedUrl] = useState(null);
  
  function handleFileSelect(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Validate image
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }
    
    // Show preview
    const reader = new FileReader();
    reader.onload = (e) => setPreview(e.target.result);
    reader.readAsDataURL(file);
  }
  
  async function handleUpload() {
    const file = document.querySelector('input[type="file"]').files[0];
    if (!file) return;
    
    try {
      const result = await uploadFile(file, 'images');
      setUploadedUrl(`http://localhost:7130${result.url}`);
      setPreview(null);
    } catch (error) {
      alert('Upload failed: ' + error.message);
    }
  }
  
  return (
    <div>
      <input 
        type="file" 
        accept="image/*" 
        onChange={handleFileSelect}
      />
      
      {preview && (
        <div>
          <img 
            src={preview} 
            style={{ maxWidth: '300px', maxHeight: '300px' }}
          />
          <button onClick={handleUpload}>Upload</button>
          <button onClick={() => setPreview(null)}>Cancel</button>
        </div>
      )}
      
      {uploadedUrl && (
        <div>
          <p>Uploaded successfully!</p>
          <img src={uploadedUrl} style={{ maxWidth: '300px' }} />
          <input value={uploadedUrl} readOnly />
        </div>
      )}
    </div>
  );
}
```

## Chunked Upload (Large Files)

```javascript
async function uploadLargeFile(file, chunkSize = 1024 * 1024) {
  const chunks = Math.ceil(file.size / chunkSize);
  const uploadId = crypto.randomUUID();
  
  for (let i = 0; i < chunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    const chunk = file.slice(start, end);
    
    const formData = new FormData();
    formData.append('chunk', chunk);
    formData.append('uploadId', uploadId);
    formData.append('chunkIndex', i);
    formData.append('totalChunks', chunks);
    
    await fetch('/api/storage/chunks', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`
      },
      body: formData
    });
    
    // Update progress
    const progress = ((i + 1) / chunks) * 100;
    console.log(`Upload progress: ${progress.toFixed(0)}%`);
  }
  
  // Finalize upload
  return fetch('/api/storage/chunks/complete', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ uploadId })
  }).then(r => r.json());
}
```

## Error Handling

```javascript
async function safeUpload(file) {
  try {
    // Pre-upload validation
    validateFile(file);
    
    // Upload
    const result = await uploadFile(file);
    
    return { success: true, data: result };
    
  } catch (error) {
    // Handle specific errors
    if (error.message.includes('too large')) {
      return { 
        success: false, 
        error: 'File exceeds size limit',
        code: 'FILE_TOO_LARGE'
      };
    }
    
    if (error.message.includes('Invalid file type')) {
      return { 
        success: false, 
        error: 'File type not allowed',
        code: 'INVALID_TYPE'
      };
    }
    
    if (error.message.includes('401')) {
      return { 
        success: false, 
        error: 'Please login to upload files',
        code: 'UNAUTHORIZED'
      };
    }
    
    // Generic error
    return { 
      success: false, 
      error: 'Upload failed. Please try again.',
      code: 'UNKNOWN'
    };
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="CDN Setup" href="/storage/cdn">
    Configure CDN for faster delivery
  </Card>
  <Card title="Storage Overview" href="/storage/overview">
    Back to storage basics
  </Card>
</CardGroup>