---
title: CDN & Performance
description: Optimize file delivery with caching, CDN setup, and performance best practices
---

# CDN & Performance

Optimize file delivery for production with caching strategies and CDN integration.

## Current Architecture

InsForge serves files directly from storage:
```
Client → InsForge API → Storage (Local/S3) → Client
```

For production, add CDN layer:
```
Client → CDN (CloudFlare/Fastly) → InsForge API → Storage
```

## Public Bucket URLs

Public buckets allow direct access without authentication:

```javascript
// Direct access to public files
const publicUrl = 'http://localhost:7130/api/storage/buckets/cdn/objects/logo.png';

// No auth header needed for public buckets
<img src={publicUrl} alt="Logo" />
```

## Setting Up CloudFlare CDN

### 1. Configure CloudFlare

```yaml
# CloudFlare configuration
domain: cdn.yourapp.com
origin: api.yourapp.com
cache_level: standard
browser_ttl: 4 hours
edge_ttl: 1 week
```

### 2. Update File URLs

```javascript
function getCdnUrl(fileUrl) {
  const isDevelopment = process.env.NODE_ENV === 'development';
  
  if (isDevelopment) {
    return `http://localhost:7130${fileUrl}`;
  }
  
  // Production CDN
  return fileUrl.replace(
    '/api/storage',
    'https://cdn.yourapp.com'
  );
}

// Usage
const file = await uploadFile(image);
const cdnUrl = getCdnUrl(file.url);
```

## Caching Strategy

### Browser Caching

```javascript
// Add cache headers for static assets
app.use('/api/storage/buckets/public/*', (req, res, next) => {
  res.set({
    'Cache-Control': 'public, max-age=86400', // 1 day
    'Expires': new Date(Date.now() + 86400000).toUTCString()
  });
  next();
});
```

### Client-Side Caching

```javascript
class CachedStorage {
  constructor() {
    this.cache = new Map();
    this.maxAge = 3600000; // 1 hour
  }
  
  async getFile(url) {
    // Check cache
    const cached = this.cache.get(url);
    if (cached && Date.now() - cached.timestamp < this.maxAge) {
      return cached.data;
    }
    
    // Fetch and cache
    const response = await fetch(url);
    const blob = await response.blob();
    
    this.cache.set(url, {
      data: blob,
      timestamp: Date.now()
    });
    
    return blob;
  }
  
  clearCache() {
    this.cache.clear();
  }
}

const storage = new CachedStorage();
const file = await storage.getFile(fileUrl);
```

## Image Optimization

### Responsive Images

```javascript
async function uploadImageWithThumbnails(file) {
  const sizes = [
    { width: 150, suffix: 'thumb' },
    { width: 500, suffix: 'medium' },
    { width: 1200, suffix: 'large' }
  ];
  
  const uploads = [];
  
  for (const size of sizes) {
    const resized = await resizeImage(file, size.width);
    const result = await uploadFile(resized, 'images');
    uploads.push({
      size: size.suffix,
      url: result.url
    });
  }
  
  // Upload original
  const original = await uploadFile(file, 'images');
  uploads.push({
    size: 'original',
    url: original.url
  });
  
  return uploads;
}

async function resizeImage(file, maxWidth) {
  return new Promise((resolve) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    img.onload = () => {
      const scale = maxWidth / img.width;
      canvas.width = maxWidth;
      canvas.height = img.height * scale;
      
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      canvas.toBlob((blob) => {
        resolve(new File([blob], file.name, { type: 'image/jpeg' }));
      }, 'image/jpeg', 0.85);
    };
    
    img.src = URL.createObjectURL(file);
  });
}
```

### Lazy Loading

```jsx
function LazyImage({ src, alt }) {
  const [imageSrc, setImageSrc] = useState(null);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setImageSrc(src);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src]);
  
  return (
    <img
      ref={imgRef}
      src={imageSrc || 'placeholder.jpg'}
      alt={alt}
      loading="lazy"
    />
  );
}
```

## S3 + CloudFront

### Configure S3 for CDN

```javascript
// AWS S3 configuration for CloudFront
const s3Config = {
  Bucket: 'your-bucket',
  CORSConfiguration: {
    CORSRules: [{
      AllowedOrigins: ['*'],
      AllowedMethods: ['GET'],
      AllowedHeaders: ['*'],
      MaxAgeSeconds: 3600
    }]
  },
  PublicAccessBlockConfiguration: {
    BlockPublicAcls: false,
    IgnorePublicAcls: false,
    BlockPublicPolicy: false,
    RestrictPublicBuckets: false
  }
};
```

### CloudFront Distribution

```javascript
const cloudFrontConfig = {
  Origins: [{
    DomainName: 'your-bucket.s3.amazonaws.com',
    Id: 'S3-your-bucket',
    S3OriginConfig: {
      OriginAccessIdentity: ''
    }
  }],
  DefaultCacheBehavior: {
    TargetOriginId: 'S3-your-bucket',
    ViewerProtocolPolicy: 'redirect-to-https',
    CachePolicyId: 'MANAGED-CachingOptimized',
    Compress: true
  },
  PriceClass: 'PriceClass_100',
  ViewerCertificate: {
    CloudFrontDefaultCertificate: true
  }
};
```

## Performance Monitoring

```javascript
class StorageMetrics {
  constructor() {
    this.metrics = [];
  }
  
  async measureUpload(file) {
    const start = performance.now();
    
    try {
      const result = await uploadFile(file);
      const duration = performance.now() - start;
      
      this.metrics.push({
        operation: 'upload',
        fileName: file.name,
        fileSize: file.size,
        duration,
        speed: file.size / (duration / 1000), // bytes/sec
        success: true
      });
      
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      
      this.metrics.push({
        operation: 'upload',
        fileName: file.name,
        fileSize: file.size,
        duration,
        success: false,
        error: error.message
      });
      
      throw error;
    }
  }
  
  getAverageSpeed() {
    const successful = this.metrics.filter(m => m.success);
    if (successful.length === 0) return 0;
    
    const totalSpeed = successful.reduce((sum, m) => sum + m.speed, 0);
    return totalSpeed / successful.length;
  }
  
  getSuccessRate() {
    if (this.metrics.length === 0) return 0;
    
    const successful = this.metrics.filter(m => m.success).length;
    return (successful / this.metrics.length) * 100;
  }
}
```

## Bandwidth Optimization

### Progressive Loading

```javascript
async function loadProgressive(imageUrl) {
  // Load thumbnail first
  const thumbUrl = imageUrl.replace('.jpg', '-thumb.jpg');
  const thumb = await fetch(thumbUrl);
  displayImage(await thumb.blob());
  
  // Load full image in background
  const full = await fetch(imageUrl);
  displayImage(await full.blob());
}
```

### Batch Downloads

```javascript
async function downloadBatch(fileUrls) {
  const promises = fileUrls.map(url => 
    fetch(url).then(r => r.blob())
  );
  
  const blobs = await Promise.all(promises);
  
  // Create zip file
  const zip = new JSZip();
  blobs.forEach((blob, i) => {
    const name = fileUrls[i].split('/').pop();
    zip.file(name, blob);
  });
  
  const zipBlob = await zip.generateAsync({ type: 'blob' });
  
  // Download zip
  const a = document.createElement('a');
  a.href = URL.createObjectURL(zipBlob);
  a.download = 'files.zip';
  a.click();
}
```

## Production Checklist

### CDN Setup
- [ ] Configure CDN provider (CloudFlare/Fastly/CloudFront)
- [ ] Set up custom domain for CDN
- [ ] Configure caching rules
- [ ] Enable compression (gzip/brotli)
- [ ] Set up SSL certificate

### Optimization
- [ ] Enable browser caching headers
- [ ] Implement image optimization
- [ ] Set up lazy loading
- [ ] Configure rate limiting
- [ ] Monitor bandwidth usage

### Security
- [ ] Validate file types
- [ ] Scan for malware
- [ ] Set up hotlink protection
- [ ] Configure CORS properly
- [ ] Implement access logging

## Cost Optimization

```javascript
// Monitor storage costs
async function getStorageStats() {
  const response = await fetch('/api/storage/stats', {
    headers: { 'Authorization': `Bearer ${adminToken}` }
  });
  
  const stats = await response.json();
  
  const costPerGB = 0.023; // S3 pricing
  const totalGB = stats.totalSize / (1024 * 1024 * 1024);
  const monthlyCost = totalGB * costPerGB;
  
  return {
    totalSize: stats.totalSize,
    totalFiles: stats.totalFiles,
    estimatedMonthlyCost: monthlyCost
  };
}
```

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Slow uploads | Check file size, network speed, consider chunking |
| High bandwidth costs | Enable CDN caching, optimize images |
| CORS errors | Configure proper CORS headers on storage |
| Cache not updating | Use cache busting with version parameters |
| Large files timeout | Implement chunked upload, increase timeouts |

## Next Steps

<CardGroup cols={2}>
  <Card title="Storage Overview" href="/storage/overview">
    Back to storage basics
  </Card>
  <Card title="File Uploads" href="/storage/file-uploads">
    Advanced upload techniques
  </Card>
</CardGroup>